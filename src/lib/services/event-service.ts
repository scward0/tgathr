import { z } from 'zod';
import { prisma } from '@/lib/prisma';
import { eventFormSchema } from '@/types/event';
import { ServiceResponse, createErrorResponse, createSuccessResponse } from '@/lib/types/service-responses';

export type EventCreationData = z.infer<typeof eventFormSchema>;

export interface EventCreationResult {
  id: string;
  name: string;
  description?: string;
  eventType: string;
  shareToken: string; // Single shareable link for self-registration
  creator: {
    id: string;
    name: string;
    email: string;
  };
}

export interface AuthenticatedUser {
  id: string;
  displayName?: string;
  primaryEmail?: string;
}

export async function createEvent(
  data: EventCreationData,
  user: AuthenticatedUser
): Promise<ServiceResponse<EventCreationResult>> {
  try {
    // Create event without participants - they will self-register via shareToken
    const event = await prisma.event.create({
      data: {
        name: data.name,
        description: data.description,
        eventType: data.eventType,
        availabilityStartDate: data.availabilityStartDate,
        availabilityEndDate: data.availabilityEndDate,
        preferredTime: data.eventType === 'single-day' ? data.preferredTime : null,
        duration: data.eventType === 'single-day' ? data.duration : null,
        eventLength: data.eventType === 'multi-day' ? data.eventLength : null,
        timingPreference: data.eventType === 'multi-day' ? data.timingPreference : null,
        finalStartDate: null,
        finalEndDate: null,
        isFinalized: false,
        expiresAt: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000),
        creatorId: user.id,
        // shareToken is auto-generated by Prisma default
      },
    });

    return createSuccessResponse({
      id: event.id,
      name: event.name,
      description: event.description ?? undefined,
      eventType: event.eventType,
      shareToken: event.shareToken,
      creator: {
        id: user.id,
        name: user.displayName || 'Event Organizer',
        email: user.primaryEmail || '',
      },
    });

  } catch (error) {
    // Error logged internally

    if (error instanceof z.ZodError) {
      return createErrorResponse('Validation error', 400, error.errors);
    }

    return createErrorResponse(
      'Failed to create event',
      500,
      error instanceof Error ? error.message : 'Unknown error'
    );
  }
}

export function validateEventData(body: unknown): ServiceResponse<EventCreationData> {
  try {
    // Cast body to object type to ensure spread operation is valid
    const bodyObj = body as Record<string, any>;

    // Handle null or undefined input
    if (!bodyObj || typeof bodyObj !== 'object') {
      return createErrorResponse('Invalid input data', 400, 'Input must be an object');
    }

    const processedBody = {
      ...bodyObj,
      availabilityStartDate: new Date(bodyObj.availabilityStartDate),
      availabilityEndDate: new Date(bodyObj.availabilityEndDate),
    };

    const validated = eventFormSchema.parse(processedBody);
    return createSuccessResponse(validated);
  } catch (error) {
    if (error instanceof z.ZodError) {
      return createErrorResponse('Validation error', 400, error.errors);
    }
    return createErrorResponse(
      'Failed to validate data',
      500,
      error instanceof Error ? error.message : 'Unknown error'
    );
  }
}